# Copyright 2025 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

"""
West command for processing configuration requirements from Config Tools.

This module implements a West command that takes a JSON generated by Config Tools
and resolves project configuration requirements, such as source files, include paths,
and component dependencies. The command helps integrate configuration changes
generated by MCUXpresso Config Tools into the project structure.

Usage:
    west cfg_resolve -b <board> <source_dir> [-Dcore_id=<core>]
"""
import subprocess
import re
import json
import os
import sys

from west import log
from west.commands import WestCommand

CFG_RESOLVE_DESCRIPTION = '''\
This command changes and configures project based on requirements from Config Tools
stored in cfg_require.json. The requirements are processed and integrated into the project configuration.
'''

class CfgResolve(WestCommand):
    """
    West command class for resolving configuration dependencies and settings.
    """
    def __init__(self):
        super().__init__(
            'cfg_resolve',
            'resolve cfg tools requirements',
            CFG_RESOLVE_DESCRIPTION,
            accepts_unknown_args=True)

    def _exit_with_error(self, message):
        """
        Log error message and exit with code -1.
        
        Args:
            message (str): Error message to log
        """
        log.err(message)
        sys.exit(-1)
    
    def do_add_parser(self, parser_adder):
        parser = parser_adder.add_parser(
            self.name,
            help=self.help,
            description=self.description)
    
        parser.add_argument('-b', '--board', help='board for which to create the project info file')
        parser.add_argument('source_dir', help="source directory for project")
        parser.add_argument('-D', action='append', dest='cmake_defines', help="CMake defines in format key=value (e.g., -Dcore_id=cm33)")

        parser.add_argument('--no_prj_update', action='store_true', help='Disable call of cfg_project_info to update project_info.json with newly changed data')
        parser.add_argument('--no_src_add', action='store_true', help='Disable adding of source files into project configuration during resolve')
        parser.add_argument('--no_src_rem', action='store_true', help='Disable removing of source files from project configuration during resolve')
        parser.add_argument('--no_incl_add', action='store_true', help='Disable adding of include paths into project configuration during resolve')
        parser.add_argument('--no_comp_add', action='store_true', help='Disable adding of components into project configuration during resolve')
        parser.add_argument('--no_json_rename', action='store_true', help='Disable renaming of requirement JSON file after processing')

        return parser

    def _relativize_paths(self, paths):
        """
        Convert absolute paths to relative paths based on the CMake file directory.
        
        Args:
            paths_list (list): List of file/directory paths to relativize
            
        Returns:
            list: List of paths relativized to the CMake file directory
        """
        if not self.cmake_file_path:
            self._exit_with_error("CMake file path not set. Cannot relativize paths.")
        
        cmake_dir = os.path.dirname(os.path.abspath(self.cmake_file_path))
        relativized_paths = []
        
        for path in paths:
            try:
                if not os.path.isabs(path):
                    abs_path = os.path.abspath(os.path.join(self.project_root, path))
                else:
                    abs_path = os.path.abspath(path)
                
                rel_path = os.path.relpath(abs_path, cmake_dir)
                
                # Normalize path separators for CMake
                rel_path = rel_path.replace('\\', '/')
                
                relativized_paths.append(rel_path)
                
            except (ValueError, OSError) as e:
                log.wrn(f"Could not relativize path '{path}': {e}. Using original path.")
                relativized_paths.append(path)
        
        return relativized_paths

    def _run_poject_update(self):
        cmd_args = ["west", "cfg_project_info", "-b", self.args.board, self.args.source_dir]
        if self.core_id:
                cmd_args.append(f"-Dcore_id={self.core_id}")

        try:
            subprocess.run(
                    cmd_args,
                    check=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
        except subprocess.CalledProcessError as e:
            self._exit_with_error(f"Failed to run project update command: {e}")
        except Exception as e:
            self._exit_with_error(f"Unexpected error during project update: {e}")

    def _parse_require_json(self):
        """
        Parse the configuration requirements JSON file.

        Returns:
            Bool: True if JSON parsing is successful, False otherwise
        """
        self.require_json_name = "cfg_require.json"
        self.require_json_path = os.path.join(self.cfg_dir, self.require_json_name)

        if os.path.isfile(self.require_json_path):
            try:
                json_str = open(self.require_json_path).read()
                self.json_output = json.loads(json_str)
                return True
            
            except json.JSONDecodeError as e:
                self._exit_with_error(f"Failed to parse JSON file {self.require_json_name}: {e}")
            except IOError as e:
                self._exit_with_error(f"Failed to read JSON file {self.require_json_name}: {e}")

        elif os.path.isfile(self.require_json_path + ".processed"):
            log.wrn(f"JSON file {self.require_json_name} already processed. \nTo use this file, remove the .processed suffix.")
            return False
        
        else:
            self._exit_with_error(f"JSON file {self.require_json_name} not found in {self.cfg_dir}")


    def _get_cmake_file_path(self, project):
        """
        Get the cmake file path and create it if it doesnt exist.
        
        Args:
            project(dict): Project dictionary from json
            
        Returns:
            str: Path to the CMake file
            
        Raises:
            Exception: If there is IOError while creating the .cmake file
        """
        cmake_path = project.get("source_generated_cmake_file_path", None)
        
        if not cmake_path:
            self._exit_with_error("source_generated_cmake_file_path not found in project configuration")

        if os.path.exists(cmake_path):
            return cmake_path
        else:
            log.wrn("No .cmake file found! Creating new file.")
            try:
                open(cmake_path, 'a').close()
                return cmake_path
            except IOError as e:
                self._exit_with_error(f"Failed to create CMake file {cmake_path}: {e}")


    def _write_cmake_file(self, new_content):
        """
        Write new content to the CMake file.

        Args:
            new_content (str): Content to be written or appended

        Raises:
            IOError: If there's an issue writing to the file
        """
        try:
            with open(self.cmake_file_path, 'a') as cmake_file:
                cmake_file.write(new_content)
        except IOError as e:
            self._exit_with_error(f"Error writing to CMake file {self.cmake_file_path}: {e}")


    def _read_cmake_file(self):
        """
        Read the content of a CMake file.
        """
        try:
            with open(self.cmake_file_path, 'r') as cmake_file:
                 self.cmake_file_content = cmake_file.read()
        except IOError as e:
            self._exit_with_error(f"Error reading CMake file {self.cmake_file_path}: {e}")


    def _check_for_duplicate_block(self, json_list, block_type):
        """
        Check if items from json_list already exist in the existing CMake blocks.

        Args:
            json_list (list): List of items from JSON to check for duplicates
            block_type (str): Type of block to check ('includes', 'sources', 'components')

        Returns:
            bool: True if any item is a duplicate, False otherwise
        """
        regex_patterns = {
            'includes': r"# Added by cfg_resolve west command\s+mcux_add_include\([\s\S]*?INCLUDES\s+((?:[^\s)]+\s*)+)\)",
            'sources': r"# Added by cfg_resolve west command\s+mcux_add_source\([\s\S]*?SOURCES\s+((?:[^\s)]+\s*)+)\)",
            'remove_sources': r"# Added by cfg_resolve west command\s+mcux_project_remove_source\([\s\S]*?SOURCES\s+((?:[^\s)]+\s*)+)\)"
        }

        regex = regex_patterns.get(block_type)

        if not regex:
            self._exit_with_error(f"Unknown block type: {block_type}")

        try:
            block_match = re.search(regex, self.cmake_file_content)
            if block_match:
                paths = block_match.group(1)
                existing_items = re.findall(r"[^\s]+", paths)

                if block_type == 'includes':
                    self.cmake_includes = existing_items
                elif block_type == 'sources':
                    self.cmake_sources = existing_items
                elif block_type == 'remove_sources':
                    self.cmake_remove_sources = existing_items
                    
                return bool(set(json_list) & set(existing_items))

            return False
        
        except re.error as e:
            self._exit_with_error(f"Regex error while checking for duplicate block: {e}")


    def _extract_unique_list(self, json_list, existing_list):
        """
        Extract unique items from a new list that are not present in the current list.

        Args:
            json_list (list): List from require json
            existing_list (list): List of existing items in .cmake file

        Returns:
            list: List of unique items not present in the current list
        """
        return [item for item in json_list if item not in existing_list]


    def _rename_processed_json(self):
        """
        Rename the processed JSON file to indicate completion.

        Renames 'cfg_require.json' to 'cfg_require.json.processed'
        to mark that the configuration has been processed.
        """
        processed_json_path = self.require_json_path.replace(".json", ".json.processed")
        try:
            os.rename(self.require_json_path, processed_json_path)
        except OSError as e:
            self._exit_with_error(f"Failed to rename processed JSON file: {self.require_json_path} - {e}")
                                                       
    def add_includes(self, project):
        """
        Add includes to the CMake configuration based on project requirements.

        Args:
            project (dict): Project configuration dictionary

        Raises:
            Exception: If include addition fails
        """
        includes_to_add = project.get("addIncludes", [])  
    
        if not includes_to_add:
            log.inf("Skipping includes addition: No includes specified")
            return

        try:
            includes_to_add = self._relativize_paths(includes_to_add)

            if self._check_for_duplicate_block(includes_to_add, 'includes'):
                includes_to_add = self._extract_unique_list(includes_to_add, self.cmake_includes)
            
            if not includes_to_add:
                log.inf("Skipping includes addition: No new unique includes to add\n")
                return

            self._generate_cmake_block(includes_to_add, 'includes')

        except Exception as e:
            self._exit_with_error(f"Failed to add includes to cmake file: {e}")



    def add_sources(self, project):
        """
        Add source files to the CMake configuration based on project requirements.

        Args:
            project (dict): Project configuration dictionary

        Raises:
            Exception: If source addition fails
        """
        sources_to_add = project.get("addFiles", [])

        if not sources_to_add:
            log.inf("Skipping sources addition: No sources specified")
            return

        try:
            sources_to_add = self._relativize_paths(sources_to_add)

            if self._check_for_duplicate_block(sources_to_add, 'sources'):
                sources_to_add = self._extract_unique_list(sources_to_add, self.cmake_sources)
        
            if not sources_to_add:
                log.inf("Skipping sources addition: No new unique source files to add\n")
                return

            self._generate_cmake_block(sources_to_add, 'sources')

        except Exception as e:
            self._exit_with_error(f"Failed to add sources to cmake file: {e}")


    def remove_files(self, project):
        """
        Remove source files from the CMake configuration based on project requirements.

        Args:
            project (dict): Project configuration dictionary

        Raises:
            Exception: If file removal fails
        """
        files_to_remove = project.get("removeFiles", [])

        if not files_to_remove:
            log.inf("Skipping file removal: No files specified")
            return
        
        try:
            files_to_remove = self._relativize_paths(files_to_remove)

            if self._check_for_duplicate_block(files_to_remove, 'remove_sources'):
                files_to_remove = self._extract_unique_list(files_to_remove, self.cmake_remove_sources)
            
            if not files_to_remove:
                log.inf("Skipping sources addition: No new unique source files to remove\n")
                return

            self._generate_cmake_block(files_to_remove, 'remove_sources')

        except Exception as e:
            self._exit_with_error(f"Failed to remove sources from cmake file: {e}")


    def add_components(self, project):
        """
        Add components to configuration file based on project requirements.

        Args:
            project (dict): Project configuration dictionary

        Raises:
            Exception: If source addition fails
        """
        self.prj_conf_file = project.get("component_edit_prj_file_path")
        components_to_add = project.get("addComponents", [])

        if not components_to_add:
            log.inf("Skipping component addition: No components specified\n")
            return
        
        if not self.prj_conf_file:
            self._exit_with_error("component_edit_prj_file_path not found in project configuration")
        
        try:
            component_regex = r"CONFIG_MCUX_COMPONENT_([^\s]+)(=y)"
            with open(self.prj_conf_file, 'r') as conf_file:
                existing_components = [
                    match.group(1) for match in re.finditer(component_regex, conf_file.read())
                ]

            comp_added = False

            for component in components_to_add:
                component_id = component.get("kconfig_id")
                if component_id not in existing_components:
                    comp_added = True
                    with open(self.prj_conf_file, 'a') as conf_file:
                        conf_file.write(f"\nCONFIG_MCUX_COMPONENT_{component_id}=y")

            if not comp_added:
                log.inf("Skipping component addition: No new unique components to add")

        except IOError as e:
            self._exit_with_error(f"Failed to read/write project configuration file {self.prj_conf_file}: {e}")
        except re.error as e:
            self._exit_with_error(f"Regex error while processing components: {e}")
        except Exception as e:
            self._exit_with_error(f"Failed to add components to project configuration: {e}")
    

    def _generate_cmake_block(self, items_list, block_type, base_path_var="${CMAKE_CURRENT_LIST_DIR}"):
        """
        Generate a CMake block for different types of operations.

        Args:
            items_list (list): List of items (files, includes, etc.) to add to the block
            block_type (str): Type of block ('includes', 'sources', 'remove_sources')
            base_path_var (str): Base path variable to use in the CMake block

        Returns:
            str: Formatted CMake block string

        Raises:
            ValueError: If block_type is not supported
        """

        if not items_list:
            return ""
        
        if not hasattr(self, 'cmake_file_path') or not self.cmake_file_path:
            self._exit_with_error("CMake file path not set. Call _get_cmake_file_path() first.")

        block_configs = {
            'includes': {
                'function': 'mcux_add_include',
                'param_name': 'INCLUDES',
                'regex': r"# Added by cfg_resolve west command\s+mcux_add_include\([\s\S]*?INCLUDES\s+(?:[^\s)]+\s*)+(\))",
                'first_item_prefix': ' ',
                'other_item_prefix': '\t\t\t ',
                'append_prefix': '\t\t\t '
            },
            'sources': {
                'function': 'mcux_add_source',
                'param_name': 'SOURCES',
                'regex': r"# Added by cfg_resolve west command\s+mcux_add_source\([\s\S]*?SOURCES\s+(?:[^\s)]+\s*)+(\))",
                'first_item_prefix': ' ',
                'other_item_prefix': '\t\t\t',
                'append_prefix': '\t\t\t'
            },
            'remove_sources': {
                'function': 'mcux_project_remove_source',
                'param_name': 'SOURCES',
                'regex': r"# Added by cfg_resolve west command\s+mcux_project_remove_source\([\s\S]*?SOURCES\s+(?:[^\s)]+\s*)+(\))",
                'first_item_prefix': ' ',
                'other_item_prefix': '\t\t\t',
                'append_prefix': '\t\t\t'
            }
        }

        config = block_configs.get(block_type)
        if not config:
            self._exit_with_error(f"Unsupported block type: {block_type}")

        try:
            self._read_cmake_file()

            block_match = re.search(config['regex'], self.cmake_file_content)
        
            if block_match:
                existing_block = block_match.group(0)
                closing_paren = block_match.group(1)

                formatted_new_items = []
                for item in items_list:
                    formatted_new_items.append(f"{config['append_prefix']}{item}")

                new_items_str = "\n".join(formatted_new_items)
                updated_block = existing_block.replace(closing_paren, f"{new_items_str}\n{closing_paren}")
                updated_content = self.cmake_file_content.replace(existing_block, updated_block)
                
                with open(self.cmake_file_path, 'w') as cmake_file:
                    cmake_file.write(updated_content)
            else:
                formatted_items = []
                for i, item in enumerate(items_list):
                    if i == 0:
                        formatted_items.append(f"{config['first_item_prefix']}{item}")
                    else:
                        formatted_items.append(f"{config['other_item_prefix']}{item}")

                items_str = "\n".join(formatted_items)

                cmake_block = f"""
# Added by cfg_resolve west command
{config['function']}(
\tBASE_PATH {base_path_var}
\t{config['param_name']}{items_str}
)
"""
                self._write_cmake_file(cmake_block)

        except re.error as e:
            self._exit_with_error(f"Regex error while generating CMake block: {e}")
        except IOError as e:
            self._exit_with_error(f"File I/O error while generating CMake block: {e}")
        except Exception as e:
            self._exit_with_error(f"Unexpected error while generating CMake block: {e}")

    def do_run(self, args, remainder):
        """
        Main execution method for the cfg_resolve west command.
        """
        try:
            self.args = args

            log.inf("=== Starting Config tools resolve request: ", colorize=True)
            log.inf(f"Source directory: {args.source_dir}")
            log.inf(f"Board: {args.board}")

            self.core_id = None
            if args.cmake_defines:
                for define in args.cmake_defines:
                    if define.startswith('core_id='):
                        self.core_id = define.split('=', 1)[1]
                        log.inf(f"Core: {self.core_id}")
                        break

            self.project_root = os.path.join(os.curdir, args.source_dir)
            self.cfg_folder_name = "cfg_tools"
            self.cfg_dir = os.path.join(self.project_root, self.cfg_folder_name)

            if not os.path.exists(self.cfg_dir):
                self._exit_with_error(f"Configuration directory not found: {self.cfg_dir}")

            if not self._parse_require_json():
                return
            
            valid_project = False
            self.projects = self.json_output.get('projects', [])
            if not self.projects:
                self._exit_with_error("No projects found in configuration file")

            for project in self.projects:
                try:
                    project_root_match = os.path.samefile(project.get("projectRootPath"), os.path.abspath(args.source_dir))
                except (TypeError, OSError) as e:
                    log.wrn(f"Cannot compare project root paths: {e}")
                    project_root_match = False

                board_match = project.get("board") == args.board
                core_match = not self.core_id or self.core_id == project.get("core_id")

                if not project_root_match or not board_match or not core_match:
                    mismatch_reasons = []
                    if not project_root_match:
                        mismatch_reasons.append(f"source directory mismatch (expected: {args.source_dir}, found: {project.get('projectRootPath')})")
                    if not board_match:
                        mismatch_reasons.append(f"board mismatch (expected: {args.board}, found: {project.get('board')})")
                    if not core_match:
                        mismatch_reasons.append(f"core_id mismatch (expected: {self.core_id}, found: {project.get('core_id')})")
                    
                    log.wrn(f"Skipping project due to: {'; '.join(mismatch_reasons)}")
                    continue
                else:
                    valid_project = True
                
                self.cmake_file_path = self._get_cmake_file_path(project)
                self._read_cmake_file()

                if (not args.no_incl_add or not args.no_src_add or not args.no_comp_add):
                    log.inf("\n=== Adding requirements to project configuration: ", colorize=True)
                    if (not args.no_incl_add):
                        log.inf("Includes")
                        self.add_includes(project)
                    
                    if (not args.no_src_add):
                        log.inf("Sources")
                        self.add_sources(project)

                    if (not args.no_comp_add):
                        log.inf("Components")
                        self.add_components(project)

                if (not args.no_src_rem):
                    log.inf("\n=== Removing files from project configuration: ", colorize=True)
                    log.inf("Sources")
                    self.remove_files(project)

                if (not args.no_json_rename):
                    self._rename_processed_json()
                    log.wrn(f"\n=== cfg_require JSON renamed to: {self.require_json_name}.processed \nTo disable renaming of the processed json file, use --no_json_rename argument")

                if (not args.no_prj_update):
                    log.inf("\n=== Updating project info: ", colorize=True)
                    log.inf("To disable this function use --no_prj_upadte argument")
                    self._run_poject_update()


            if not valid_project:
                self._exit_with_error(f"No projects could be processed. All {len(self.projects)} project(s) in the configuration have misaligned parameters compared to the requested source directory '{args.source_dir}', board '{args.board}'" + (f", and core_id '{self.core_id}'" if self.core_id else "") + ". Please check the configuration file and ensure the project parameters match your request.")
    
        except Exception as e:
            self._exit_with_error(f"Unexpected error during execution: {e}")