# Copyright (c) 2018 Foundries.io
# Copyright 2024-2025 NXP
#
# SPDX-License-Identifier: Apache-2.0

import argparse
import os
import pathlib
import shlex
import sys
import yaml
import hashlib
import shutil
import re

from west import log
from west.configuration import config
from zcmake import DEFAULT_CMAKE_GENERATOR, run_cmake, run_build, CMakeCache
from build_helpers import is_mcux_build, find_build_dir, load_domains, is_from_same_disk, \
                          FIND_BUILD_DIR_DESCRIPTION

from zephyr_ext_common import Forceable

script_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))

_ARG_SEPARATOR = '--'

SYSBUILD_PROJ_DIR = pathlib.Path(__file__).resolve().parent.parent.parent \
                    / pathlib.Path('cmake/extension/sysbuild')

BUILD_HELP_DOC_URL = 'https://mcuxpresso.nxp.com/mcuxsdk/latest/html/develop/build_system/Build_And_Configuration_System_Based_On_CMake_And_Kconfig.html#build'

BUILD_USAGE = '''\
west build [-h] [-b BOARD[@REV]]] [-d BUILD_DIR]
           [-t TARGET] [-p {auto, always, never}] [-c] [--cmake-only]
           [-n] [-o BUILD_OPT] [-f]
           [--sysbuild | --no-sysbuild] [--domain DOMAIN]
           [source_dir] -- [cmake_opt [cmake_opt ...]]
'''

BUILD_DESCRIPTION = f'''\
Convenience wrapper for building Zephyr applications.

{FIND_BUILD_DIR_DESCRIPTION}

For more help, see: {BUILD_HELP_DOC_URL}

positional arguments:
  source_dir            application source directory
  cmake_opt             extra options to pass to cmake; implies -c
                        (these must come after "--" as shown above)
'''

PRISTINE_DESCRIPTION = """\
A "pristine" build directory is empty. The -p option controls
whether the build directory is made pristine before the build
is done. A bare '--pristine' with no value is the same as
--pristine=always. Setting --pristine=auto uses heuristics to
guess if a pristine build may be necessary."""

_CMAKE_TRUE = "TRUE"
_CMAKE_FALSE = "FALSE"

NO_GUI_TOOLCHAIN = ['armgcc']

# log module is deprecated
def _banner(msg):
    log.inf('=== west build: ' + msg, colorize=True)

def config_get(option, fallback):
    return config.get('build', option, fallback=fallback)

def config_getboolean(option, fallback):
    return config.getboolean('build', option, fallback=fallback)

class AlwaysIfMissing(argparse.Action):

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values or 'always')

class Build(Forceable):

    def __init__(self):
        super(Build, self).__init__(
            'build',
            # Keep this in sync with the string in west-commands.yml.
            'compile a Zephyr application',
            BUILD_DESCRIPTION,
            accepts_unknown_args=True)

        self.source_dir = None
        '''Source directory for the build, or None on error.'''

        self.build_dir = None
        '''Final build directory used to run the build, or None on error.'''

        self.created_build_dir = False
        '''True if the build directory was created; False otherwise.'''

        self.run_cmake = False
        '''True if CMake was run; False otherwise.

        Note: this only describes CMake runs done by this command. The
        build system generated by CMake may also update itself due to
        internal logic.'''

        self.cmake_cache = None
        '''Final parsed CMake cache for the build, or None on error.'''

        self.cmake_temp_dir = None
        '''The temporary build directory for standalone project generation.'''

    def do_add_parser(self, parser_adder):
        parser = parser_adder.add_parser(
            self.name,
            help=self.help,
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description=self.description,
            usage=BUILD_USAGE)

        # Remember to update west-completion.bash if you add or remove
        # flags

        parser.add_argument('-b', '--board',
                        help='board to build for with optional board revision')
        parser.add_argument('--device', help='device to build for with optional device revision')

        # Hidden option for backwards compatibility
        parser.add_argument('-s', '--source-dir', help=argparse.SUPPRESS)
        parser.add_argument('-d', '--build-dir',
                            help='build directory to create or use')
        self.add_force_arg(parser)

        group = parser.add_argument_group('cmake and build tool')
        group.add_argument('-c', '--cmake', action='store_true',
                           help='force a cmake run')
        group.add_argument('--cmake-only', action='store_true',
                           help="just run cmake; don't build (implies -c)")
        group.add_argument('--domain', action='append',
                           help='''execute build tool (make or ninja) only for
                           given domain''')
        group.add_argument('-t', '--target',
                           help='''run build system target TARGET
                           (try "-t usage")''')
        group.add_argument('-T', '--test-item',
                           help='''Build based on test data in testcase.yaml
                           or sample.yaml. If source directory is not used
                           an argument has to be defined as
                           SOURCE_PATH/TEST_NAME.
                           E.g. samples/hello_world/sample.basic.helloworld.
                           If source directory is passed
                           then "TEST_NAME" is enough.''')
        group.add_argument('-o', '--build-opt', default=[], action='append',
                           help='''options to pass to the build tool
                           (make or ninja); may be given more than once''')
        group.add_argument('-n', '--just-print', '--dry-run', '--recon',
                            dest='dry_run', action='store_true',
                            help="just print build commands; don't run them")
        group.add_argument('-S', '--snippet', dest='snippets',
                           action='append', default=[],
                           help='''add the argument to SNIPPET; may be given
                           multiple times. Forces CMake to run again if given.
                           Do not use this option with manually specified
                           -DSNIPPET... cmake arguments: the results are
                           undefined''')
        group.add_argument('--toolchain', dest='toolchain', action='store',
                           default='armgcc', help='Specify toolchain')
        group.add_argument('--compiler', dest='compiler', action='store', help='Specify compiler. Compiler must follow toolchain.')        
        group.add_argument('--config', dest='config', action='store', 
                           default=None, help='SDK build config type')
        group.add_argument('-k', '--kit', action='store', help='Kit id')
        group.add_argument('--shield', action='store', help='')
        group.add_argument('--hint', action='store_true', default=False, help='Execute external assistant command like'
                                                                              'west list_project')
        group.add_argument('-nsc','--no_sanity_check', dest='no_sanity_check', action='store_true', default=False, help='Skip sanity check')
        group = parser.add_mutually_exclusive_group()
        group.add_argument('--sysbuild', action='store_true',
                           help='''create multi domain build system''')
        group.add_argument('--no-sysbuild', action='store_true',
                           help='''do not create multi domain build system
                                   (default)''')

        group = parser.add_argument_group('pristine builds',
                                          PRISTINE_DESCRIPTION)
        group.add_argument('-p', '--pristine', choices=['auto', 'always',
                            'never'], action=AlwaysIfMissing, nargs='?',
                            help='pristine build folder setting')
        group.add_argument('--enable-all-drivers', action='store_true',
                           help='''Enable all base SDK drivers starting with "mcux_component_driver" if the dependency is ok which technically equals add "default y" to all driver kconfig symbol.
                           This is especially useful for device specific platform library project to get all depended and supported drivers enabled automatically without manually specify all the drivers in prj.conf.''')
        return parser

    def do_run(self, args, remainder):
        self.args = args        # Avoid having to pass them around
        self.config_board = config_get('board', None)
        self.config_device = config_get('device', None)
        log.dbg('args: {} remainder: {}'.format(args, remainder),
                level=log.VERBOSE_EXTREME)
        # Store legacy -s option locally
        source_dir = self.args.source_dir
        self._parse_remainder(remainder)
        # Parse testcase.yaml or sample.yaml files for additional options.
        if self.args.test_item:
            # we get path + testitem
            item = os.path.basename(self.args.test_item)
            if self.args.source_dir:
                test_path = self.args.source_dir
            else:
                test_path = os.path.dirname(self.args.test_item)
            if test_path and os.path.exists(test_path):
                self.args.source_dir = test_path
                if not self._parse_test_item(item):
                    log.die("No test metadata found")
            else:
                log.die("test item path does not exist")

        if source_dir:
            if self.args.source_dir:
                log.die("source directory specified twice:({} and {})".format(
                                            source_dir, self.args.source_dir))
            self.args.source_dir = source_dir
        log.dbg('source_dir: {} cmake_opts: {}'.format(self.args.source_dir,
                                                       self.args.cmake_opts),
                level=log.VERBOSE_EXTREME)
        self._sanity_precheck()
        self._setup_build_dir()

        if args.pristine is not None:
            pristine = args.pristine
        else:
            # Load the pristine={auto, always, never} configuration value
            pristine = config_get('pristine', 'never')
            if pristine not in ['auto', 'always', 'never']:
                log.wrn(
                    'treating unknown build.pristine value "{}" as "never"'.
                    format(pristine))
                pristine = 'never'
        self.auto_pristine = pristine == 'auto'

        log.dbg('pristine: {} auto_pristine: {}'.format(pristine,
                                                        self.auto_pristine),
                level=log.VERBOSE_VERY)
        if is_mcux_build(self.build_dir):
            if pristine == 'always':
                self._run_pristine()
                self.run_cmake = True
            else:
                self._update_cache()
                if (self.args.cmake or self.args.cmake_opts or
                        self.args.cmake_only or self.args.snippets):
                    self.run_cmake = True
        else:
            self.run_cmake = True
        self.source_dir = self._find_source_dir()
        self._sanity_check()

        device, origin = self._find_device()
        board, origin = self._find_board()
        self._run_cmake(board, device, origin, self.args.cmake_opts)
        if args.cmake_only:
            return

        self._sanity_check()
        self._update_cache()
        self.domains = load_domains(self.build_dir)

        self._run_build(args.target, args.domain)

    def _find_board(self):
        board, origin = None, None
        if self.cmake_cache:
            board, origin = (self.cmake_cache.get('CACHED_BOARD'),
                             'CMakeCache.txt')

            # A malformed CMake cache may exist, but not have a board.
            # This happens if there's a build error from a previous run.
            if board is not None:
                return (board, origin)

        if self.args.board:
            board, origin = self.args.board, 'command line'
        elif 'BOARD' in os.environ:
            board, origin = os.environ['BOARD'], 'env'
        elif self.config_board is not None:
            board, origin = self.config_board, 'configfile'
        return board, origin

    def _find_device(self):
        device, origin = None, None
        if self.cmake_cache:
            device, origin = (self.cmake_cache.get('CACHED_DEVICE'),
                             'CMakeCache.txt')

            # A malformed CMake cache may exist, but not have a device.
            # This happens if there's a build error from a previous run.
            if device is not None:
                return (device, origin)

        if self.args.device:
            device, origin = self.args.device, 'command line'
        elif 'DEVICE' in os.environ:
            device, origin = os.environ['DEVICE'], 'env'
        elif self.config_device is not None:
            device, origin = self.config_device, 'configfile'
        return device, origin

    def _parse_remainder(self, remainder):
        self.args.source_dir = None
        self.args.cmake_opts = None

        try:
            # Only one source_dir is allowed, as the first positional arg
            if remainder[0] != _ARG_SEPARATOR:
                self.args.source_dir = remainder[0]
                remainder = remainder[1:]
            # Only the first argument separator is consumed, the rest are
            # passed on to CMake
            if not remainder:
                return
            if remainder[0] == _ARG_SEPARATOR:
                remainder = remainder[1:]
            if remainder:
                self.args.cmake_opts = remainder
        except IndexError:
            pass

    def _parse_test_item(self, test_item):
        found_test_metadata = False
        for yp in ['sample.yaml', 'testcase.yaml']:
            yf = os.path.join(self.args.source_dir, yp)
            if not os.path.exists(yf):
                continue
            found_test_metadata = True
            with open(yf, 'r') as stream:
                try:
                    y = yaml.safe_load(stream)
                except yaml.YAMLError as exc:
                    log.die(exc)
            common = y.get('common')
            tests = y.get('tests')
            if not tests:
                log.die(f"No tests found in {yf}")
            if test_item not in tests:
                log.die(f"Test item {test_item} not found in {yf}")
            item = tests.get(test_item)

            sysbuild = False
            extra_dtc_overlay_files = []
            extra_overlay_confs = []
            extra_conf_files = []
            required_snippets = []
            for section in [common, item]:
                if not section:
                    continue
                sysbuild = section.get('sysbuild', sysbuild)
                for data in [
                        'extra_args',
                        'extra_configs',
                        'extra_conf_files',
                        'extra_overlay_confs',
                        'extra_dtc_overlay_files',
                        'required_snippets'
                        ]:
                    extra = section.get(data)
                    if not extra:
                        continue
                    if isinstance(extra, str):
                        arg_list = extra.split(" ")
                    else:
                        arg_list = extra

                    if data == 'extra_configs':
                        args = ["-D{}".format(arg.replace('"', '\"')) for arg in arg_list]
                    elif data == 'extra_args':
                        # Retain quotes around config options
                        config_options = [arg for arg in arg_list if arg.startswith("CONFIG_")]
                        non_config_options = [arg for arg in arg_list if not arg.startswith("CONFIG_")]
                        args = ["-D{}".format(a.replace('"', '\"')) for a in config_options]
                        args.extend(["-D{}".format(arg.replace('"', '')) for arg in non_config_options])
                    elif data == 'extra_conf_files':
                        extra_conf_files.extend(arg_list)
                        continue
                    elif data == 'extra_overlay_confs':
                        extra_overlay_confs.extend(arg_list)
                        continue
                    elif data == 'extra_dtc_overlay_files':
                        extra_dtc_overlay_files.extend(arg_list)
                        continue
                    elif data == 'required_snippets':
                        required_snippets.extend(arg_list)
                        continue

                    if self.args.cmake_opts:
                        self.args.cmake_opts.extend(args)
                    else:
                        self.args.cmake_opts = args

            self.args.sysbuild = sysbuild

        if found_test_metadata:
            args = []
            if extra_conf_files:
                args.append(f"CONF_FILE=\"{';'.join(extra_conf_files)}\"")

            if extra_dtc_overlay_files:
                args.append(f"DTC_OVERLAY_FILE=\"{';'.join(extra_dtc_overlay_files)}\"")

            if extra_overlay_confs:
                args.append(f"OVERLAY_CONFIG=\"{';'.join(extra_overlay_confs)}\"")

            if required_snippets:
                args.append(f"SNIPPET=\"{';'.join(required_snippets)}\"")

            # Build the final argument list
            args_expanded = ["-D{}".format(a.replace('"', '')) for a in args]

            if self.args.cmake_opts:
                self.args.cmake_opts.extend(args_expanded)
            else:
                self.args.cmake_opts = args_expanded

        return found_test_metadata

    def _sanity_precheck(self):
        app = self.args.source_dir
        if app:
            self.check_force(
                os.path.isdir(app),
                'source directory {} does not exist'.format(app))
            self.check_force(
                'CMakeLists.txt' in os.listdir(app),
                "{} doesn't contain a CMakeLists.txt".format(app))

    def _update_cache(self):
        try:
            self.cmake_cache = CMakeCache.from_build_dir(self.build_dir)
        except FileNotFoundError:
            pass

    def _setup_build_dir(self):
        # Initialize build_dir and created_build_dir attributes.
        # If we created the build directory, we must run CMake.
        log.dbg('setting up build directory', level=log.VERBOSE_EXTREME)
        # The CMake Cache has not been loaded yet, so this is safe
        board, _ = self._find_board()
        source_dir = self._find_source_dir()
        app = os.path.split(source_dir)[1]
        # for standalone project, use a temporary build directory if using the directory from different disk on Windows
        if self.args.target == 'standalone_project' and \
            os.name == 'nt' and \
            self.args.build_dir and \
            os.path.isabs(self.args.build_dir) and \
            not is_from_same_disk(self.args.build_dir):
            build_dir = self._prepare_standalone_project_dir(self.args.build_dir, board, source_dir, app)
        else:
            build_dir = find_build_dir(self.args.build_dir, board=board,
                                   source_dir=source_dir, app=app)
        if not build_dir:
            log.die('Unable to determine a default build folder. Check '
                    'your build.dir-fmt configuration option')

        if os.path.exists(build_dir):
            if not os.path.isdir(build_dir):
                log.die('build directory {} exists and is not a directory'.
                        format(build_dir))
        else:
            os.makedirs(build_dir, exist_ok=False)
            self.created_build_dir = True
            self.run_cmake = True

        self.build_dir = build_dir

    def _find_source_dir(self):
        # Initialize source_dir attribute, either from command line argument,
        # implicitly from the build directory's CMake cache, or using the
        # default (current working directory).
        log.dbg('setting up source directory', level=log.VERBOSE_EXTREME)
        if self.args.source_dir:
            source_dir = self.args.source_dir
        elif self.cmake_cache:
            source_dir = self.cmake_cache.get('APP_DIR')

            if not source_dir:
                source_dir = self.cmake_cache.get('APPLICATION_SOURCE_DIR')

            if not source_dir:
                source_dir = self.cmake_cache.get('CMAKE_HOME_DIRECTORY')

            if not source_dir:
                # This really ought to be there. The build directory
                # must be corrupted somehow. Let's see what we can do.
                log.die('build directory', self.build_dir,
                        'CMake cache has no CMAKE_HOME_DIRECTORY;',
                        'please give a source_dir')
        else:
            source_dir = os.getcwd()
        return os.path.abspath(source_dir)

    def _sanity_check_source_dir(self):
        if self.source_dir == self.build_dir:
            # There's no forcing this.
            log.die('source and build directory {} cannot be the same; '
                    'use --build-dir {} to specify a build directory'.
                    format(self.source_dir, self.build_dir))

        if is_from_same_disk(self.source_dir):
            srcrel = os.path.relpath(self.source_dir)
        else:
            srcrel = os.path.abspath(self.source_dir)
        self.check_force(
            not is_mcux_build(self.source_dir),
            'it looks like {srcrel} is a build directory: '
            'did you mean --build-dir {srcrel} instead?'.
            format(srcrel=srcrel))
        self.check_force(
            'CMakeLists.txt' in os.listdir(self.source_dir),
            'source directory "{srcrel}" does not contain '
            'a CMakeLists.txt; is this really what you '
            'want to build? (Use -s SOURCE_DIR to specify '
            'the application source directory)'.
            format(srcrel=srcrel))

    def _sanity_check(self):
        # Sanity check the build configuration.
        # Side effect: may update cmake_cache attribute.
        if self.args.no_sanity_check:
            return
        log.dbg('sanity checking the build', level=log.VERBOSE_EXTREME)
        self._sanity_check_source_dir()

        if not self.cmake_cache:
            return          # That's all we can check without a cache.

        if "CMAKE_PROJECT_NAME" not in self.cmake_cache:
            # This happens sometimes when a build system is not
            # completely generated due to an error during the
            # CMake configuration phase.
            self.run_cmake = True

        cached_proj = self.cmake_cache.get('APPLICATION_SOURCE_DIR')
        cached_app = self.cmake_cache.get('APP_DIR')
        # if APP_DIR is None but APPLICATION_SOURCE_DIR is set, that indicates
        # an older build folder, this still requires pristine.
        if cached_app is None and cached_proj:
            cached_app = cached_proj

        log.dbg('APP_DIR:', cached_app, level=log.VERBOSE_EXTREME)
        source_abs = (os.path.abspath(self.args.source_dir)
                      if self.args.source_dir else None)
        cached_abs = os.path.abspath(cached_app) if cached_app else None

        log.dbg('pristine:', self.auto_pristine, level=log.VERBOSE_EXTREME)

        # If the build directory specifies a source app, make sure it's
        # consistent with --source-dir.
        apps_mismatched = (source_abs and cached_abs and
            pathlib.Path(source_abs).resolve() != pathlib.Path(cached_abs).resolve())

        self.check_force(
            not apps_mismatched or self.auto_pristine,
            'Build directory "{}" is for application "{}", but source '
            'directory "{}" was specified; please clean it, use --pristine, '
            'or use --build-dir to set another build directory'.
            format(self.build_dir, cached_abs, source_abs))

        if apps_mismatched:
            self.run_cmake = True  # If they insist, we need to re-run cmake.

        # If CACHED_BOARD is not defined, we need some other way to
        # find the board.
        cached_board = self.cmake_cache.get('CACHED_BOARD')
        if cached_board:
            log.dbg('CACHED_BOARD:', cached_board, level=log.VERBOSE_EXTREME)
        else:
            log.dbg('CACHED_BOARD: not defined', level=log.VERBOSE_EXTREME)

        cached_device = self.cmake_cache.get('CACHED_DEVICE')
        if cached_device:
            log.dbg('CACHED_DEVICE:', cached_device, level=log.VERBOSE_EXTREME)
        else:
            log.dbg('CACHED_DEVICE: not defined', level=log.VERBOSE_EXTREME)

        # If apps_mismatched and self.auto_pristine are true, we will
        # run pristine on the build, invalidating the cached
        # board. In that case, we need some way of getting the board.
        self.check_force(((cached_board or cached_device) and not (apps_mismatched and self.auto_pristine))
                         or self.args.board or self.config_board or os.environ.get('BOARD') or self.args.device or self.config_device or os.environ.get('DEVICE'),
                         'Cached board or device not defined, please provide it '
                         '(for board'
                         'provide --board, set default with '
                         '"west config build.board <BOARD>", or set '
                         'BOARD in the environment)'
                         '(for device'
                         'provide --device, set default with '
                         '"west config build.device <DEVICE>", or set '
                         'DEVICE in the environment)')

        if cached_board:
            # Check consistency between cached board and --board.
            boards_mismatched = (self.args.board and cached_board and
                                 self.args.board != cached_board)
            self.check_force(
                not boards_mismatched or self.auto_pristine,
                'Build directory {} targets board {}, but board {} was specified. '
                '(Clean the directory, use --pristine, or use --build-dir to '
                'specify a different one.)'.
                format(self.build_dir, cached_board, self.args.board))

        if cached_device:
            # Check consistency between cached device and --device.
            devices_mismatched = (self.args.device and cached_device and
                                  self.args.device != cached_device)
            self.check_force(
                not devices_mismatched or self.auto_pristine,
                'Build directory {} targets device {}, but device {} was specified. '
                '(Clean the directory, use --pristine, or use --build-dir to '
                'specify a different one.)'.
                format(self.build_dir, cached_device, self.args.device))

        if self.auto_pristine and (apps_mismatched or boards_mismatched or devices_mismatched):
            self._run_pristine()
            self.cmake_cache = None
            log.dbg('run_cmake:', True, level=log.VERBOSE_EXTREME)
            self.run_cmake = True

            # Tricky corner-case: The user has not specified a build folder but
            # there was one in the CMake cache. Since this is going to be
            # invalidated, reset to CWD and re-run the basic tests.
            if (((boards_mismatched or devices_mismatched) and not apps_mismatched) and
                    (not source_abs and cached_abs)):
                self.source_dir = self._find_source_dir()
                self._sanity_check_source_dir()

    def _run_cmake(self, board, device, origin, cmake_opts):
        if (board is None and device is None) and (config_getboolean('board_warn', True) or config_getboolean('build.device_warn', True)):
            log.wrn('This looks like a fresh build and BOARD/DEVICE is unknown;',
                    "so it probably won't work. To fix, use",
                    '--board=<your-board> or --device=<your-device>')
            log.inf('Note: to silence the above message, run',
                    "'west config build.board_warn false' or 'west config build.device_warn false'")
        if not self.run_cmake:
            return

        self.banner('generating a build system')

        if board is not None and origin != 'CMakeCache.txt':
            cmake_opts = ['-Dboard={}'.format(board)]
        else:
            cmake_opts = []

        if device is not None and origin != 'CMakeCache.txt':
            if len(cmake_opts) == 0:
                cmake_opts = ['-Ddevice={}'.format(device)]
            else:
                cmake_opts.append('-Ddevice={}'.format(device))

        if self.args.cmake_opts:
            cmake_opts.extend(self.args.cmake_opts)
        if self.args.snippets:
            cmake_opts.append(f'-DSNIPPET={";".join(self.args.snippets)}')

        user_args = config_get('cmake-args', None)
        if user_args:
            cmake_opts.extend(shlex.split(user_args))

        config_sysbuild = config_getboolean('sysbuild', False)
        if self.args.sysbuild or (config_sysbuild and not self.args.no_sysbuild):
            cmake_opts.extend(['-S{}'.format(SYSBUILD_PROJ_DIR),
                               '-DAPP_DIR:PATH={}'.format(self.source_dir)])
        else:
            # self.args.no_sysbuild == True or config sysbuild False
            cmake_opts.extend(['-S{}'.format(self.source_dir)])

        config_enable_all_drivers = config_getboolean('enable_all_drivers', False)
        if self.args.enable_all_drivers or config_enable_all_drivers:
            cmake_opts.append('-DENABLE_ALL_DRIVERS=True')
        else:
            cmake_opts.append('-DENABLE_ALL_DRIVERS=False')

        extra_args = {
            'SdkRootDirPath': pathlib.Path(__file__).resolve().parent.parent.parent.as_posix(),
            "HINT": self.args.hint
            }
        if self.args.toolchain == 'zephyr':
            extra_args['ZEPHYR_SDK'] = 'y'
            self.args.toolchain = 'armgcc'
        if self.args.kit:
            extra_args['kit'] = self.args.kit
        if self.args.shield:
            extra_args['shield'] = self.args.shield
        extra_args['CONFIG_TOOLCHAIN'] = self.args.toolchain

        if self.args.target == 'guiproject':
            if self.args.toolchain in NO_GUI_TOOLCHAIN:
                self.die(f'{self.args.toolchain} does not support target guiproject')
            extra_args['GENERATE_GUI_PROJECT'] = _CMAKE_TRUE

        if self.args.target == 'standalone_project':
            if self.args.sysbuild:
                extra_args['SYSBUILD_GENERATE_STANDALONE_PROJECT'] = _CMAKE_TRUE
            else:
                extra_args['GENERATE_STANDALONE_PROJECT'] = _CMAKE_TRUE

        if self.args.compiler:
            if self.args.toolchain == 'armgcc':
                if self.args.compiler != 'gcc':
                    log.die(f'compiler {self.args.compiler} not supported with toolchain armgcc or zephyr')
            elif self.args.toolchain == 'iar':
                if self.args.compiler != 'iar':
                    log.die(f'compiler {self.args.compiler} not supported with toolchain iar')
            elif self.args.toolchain == 'mdk':
                if self.args.compiler not in ['armcc', 'armclang']:
                    log.die(f'compiler {self.args.compiler} not supported with toolchain mdk')
            
            extra_args['CONFIG_COMPILER'] = self.args.compiler

        for k,v in extra_args.items():
            cmake_opts.extend([f'-D{k}={v}'])
        build_type = self.args.config
        if not build_type:
            build_type = self._get_default_build_type(cmake_opts)
            self.small_banner(f'Build the default target {build_type}')
        cmake_opts.append(f'-DCMAKE_BUILD_TYPE={build_type}')
        # Invoke CMake from the current working directory using the
        # -S and -B options (officially introduced in CMake 3.13.0).
        # This is important because users expect invocations like this
        # to Just Work:
        #
        # west build -- -DOVERLAY_CONFIG=relative-path.conf
        # final_cmake_args = ['-DWEST_PYTHON={}'.format(pathlib.Path(sys.executable).as_posix()),
        final_cmake_args = ['-B{}'.format(self.build_dir),
                            '-G{}'.format(config_get('generator',
                                                     DEFAULT_CMAKE_GENERATOR))]
        if cmake_opts:
            final_cmake_args.extend(cmake_opts)

        # Translate CONF_FILE to absolute path
        final_cmake_args = self._translate_conf_file_path(final_cmake_args)
        # Translate CUSTOM_BOARD_ROOT to absolute path
        final_cmake_args = self._translate_custom_board_path(final_cmake_args)
        run_cmake(final_cmake_args, dry_run=self.args.dry_run)

    def _run_pristine(self):
        self.banner('making build dir {} pristine'.format(self.build_dir))
        if not is_mcux_build(self.build_dir):
            log.die('Refusing to run pristine on a folder that is not a '
                    'Zephyr build system')

        cache = CMakeCache.from_build_dir(self.build_dir)

        app_src_dir = cache.get('APPLICATION_SOURCE_DIR')
        app_bin_dir = cache.get('APPLICATION_BINARY_DIR')

        cmake_args = [f'-DBINARY_DIR={app_bin_dir}',
                      f'-DSOURCE_DIR={app_src_dir}',
                      '-P', cache['SdkRootDirPath'] + '/cmake/extension/pristine.cmake']
        run_cmake(cmake_args, cwd=self.build_dir, dry_run=self.args.dry_run)

    def _run_build(self, target, domain):
        if target:
            if self.cmake_cache:
                toolchain = self.cmake_cache.get('CONFIG_TOOLCHAIN')
            else:
                toolchain = self.args.toolchain
            if target == 'guiproject' and toolchain in NO_GUI_TOOLCHAIN:
                self.die(f'{self.args.toolchain} does not support target guiproject')
            self.banner('running target {}'.format(target))
        elif self.run_cmake:
            self.banner('building application')
        extra_args = ['--target', target] if target else []
        if self.args.build_opt:
            extra_args.append('--')
            extra_args.extend(self.args.build_opt)
        if self.args.verbose:
            self._append_verbose_args(extra_args,
                                      not bool(self.args.build_opt))

        domains = load_domains(self.build_dir)
        build_dir_list = []

        if domain is None:
            # If no domain is specified, we just build top build dir as that
            # will build all domains.
            build_dir_list = [domains.get_top_build_dir()]
        else:
            self.banner('building domain(s): {}'.format(' '.join(domain)))
            domain_list = domains.get_domains(domain)
            for d in domain_list:
                build_dir_list.append(d.build_dir)

        for b in build_dir_list:
            run_build(b, extra_args=extra_args,
                      dry_run=self.args.dry_run)
        # remove the temporary build directory if it was created
        if self.cmake_temp_dir and os.path.exists(self.cmake_temp_dir):
            shutil.rmtree(self.cmake_temp_dir)

    def _append_verbose_args(self, extra_args, add_dashes):
        # These hacks are only needed for CMake versions earlier than
        # 3.14. When Zephyr's minimum version is at least that, we can
        # drop this nonsense and just run "cmake --build BUILD -v".
        self._update_cache()
        if not self.cmake_cache:
            return
        generator = self.cmake_cache.get('CMAKE_GENERATOR')
        if not generator:
            return
        # Substring matching is for things like "Eclipse CDT4 - Ninja".
        if 'Ninja' in generator:
            if add_dashes:
                extra_args.append('--')
            extra_args.append('-v')
        elif generator == 'Unix Makefiles':
            if add_dashes:
                extra_args.append('--')
            extra_args.append('VERBOSE=1')

    def _get_default_build_type(self, cmake_opts):
        build_type = 'debug'
        try:
            sys.path.insert(0, script_dir)
            from misc import sdk_project_target

            cmake_opt_dict = {}
            for opt in cmake_opts:
                opt = opt[2:]
                if '=' not in opt:
                    continue
                k, v = opt.split('=')
                cmake_opt_dict[k.lower()] = v
            board_core = cmake_opt_dict.get('board', '')
            if cmake_opt_dict.get('core_id'):
                board_core = board_core + '@' + cmake_opt_dict['core_id']
            op = sdk_project_target.MCUXRepoProjects()
            if cmake_opt_dict.get('sdkrootdirpath', '') not in self.source_dir:
                # Freestanding example's example.yml is out of tree, need parse it to get the real example.yml location
                source_example_yml = yaml.safe_load(open(os.path.join(self.source_dir, 'example.yml'), 'r'))
                _, example_data = next(iter(source_example_yml.items()))
                repo_source_dir = example_data.get('contents', {}).get('meta_path', '')
                app_path = os.path.join(cmake_opt_dict.get('sdkrootdirpath', ''), repo_source_dir)
            else:
                app_path = (pathlib.Path(self.source_dir) / 'example.yml').relative_to(pathlib.Path(cmake_opt_dict.get('sdkrootdirpath', ''))).as_posix()
            matched_cases = op.search_app_targets(
                app_path=app_path,
                board_cores_filter=[board_core],
                shields_filter=[cmake_opt_dict['shield']] if cmake_opt_dict.get('shield') else [],
                devices_filter=[cmake_opt_dict['device']] if cmake_opt_dict.get('device') else [],
                toolchains_filter=[cmake_opt_dict['config_toolchain']] if cmake_opt_dict.get('config_toolchain') else [],
                targets_filter=[],
                is_pick_one_target_for_app=False,
                validate=False
            )
            if not matched_cases:
                raise Exception
            matched_types = [case.target for case in matched_cases]
            matched_types.sort()
            # 'debug' takes the highest priority
            build_type = 'debug' if 'debug' in matched_types else matched_types[0]
        except Exception as _:
            pass
        finally:
            return build_type

    def _prepare_standalone_project_dir(self, build_dir, board, source_dir, app):
        # TODO : Improve generator script to remove this workaround
        # For windows OS, standalone_project can't be created on different disk drive because there is no way to
        # calculate relative path for paths from different disk drive. But this is a must-have step for current generator scripts.
        # So if you specifiy a build folder from different disk drive, we will first create prjoject in a temporary folder which 
        # is in the same disk drive as the repo folder, and finally copy the project to user specify folder.

        user_build_drive = os.path.splitdrive(build_dir)[0].lower()
        # make sure the disk drive exists
        if not os.path.exists(user_build_drive):
            self.die(f"Disk {user_build_drive} does not exist.")

        if not board or not source_dir:
            self.die("Please do pristine build for standalone project")

        temp_build_dir = find_build_dir(None, board=board, source_dir=source_dir, app=app)
        # Add md5 to the temporary build folder name to avoid collision with other build folders
        temp_build_dir = os.path.join(temp_build_dir, str(hashlib.md5((source_dir + board).encode('utf-8')).hexdigest())[0:7])
        self.cmake_temp_dir = temp_build_dir

        self.args.build_dir = temp_build_dir
        args = ['-DTEMP_BUILD_DIR:PATH={}'.format(temp_build_dir), '-DFINAL_BUILD_DIR:PATH={}'.format(build_dir)]
        if self.args.cmake_opts:
            self.args.cmake_opts.extend(args)
        else:
            self.args.cmake_opts = args

        return self.args.build_dir

    def _translate_conf_file_path(self, cmake_args):
        '''
        Translate CONF_FILE to absolute path.
        If developer give a file relative to the path which invoking west command, it will translate it to absolute path.
        This way can prevent the error when using CONF_FILE with relative path, developer invoke west command out of SdkRootDirPath, or use sysbuild.
        '''
        pattern = re.compile(r'-D.*CONF_FILE=(.*)')
        return self._translate_macro_variable_path(cmake_args, pattern)

    def _translate_custom_board_path(self, cmake_args):
        '''
        Translate CUSTOM_BOARD_ROOT to absolute path.
        '''
        pattern = re.compile(r'-D.*CUSTOM_BOARD_ROOT=(.*)')
        return self._translate_macro_variable_path(cmake_args, pattern)

    def _translate_macro_variable_path(self, cmake_args, pattern):
        final_cmake_opts = []
        for item in cmake_args:
            match = pattern.match(item)
            if not match:
                final_cmake_opts.append(item)
                continue
            temp = []
            conf_file_array = match.group(1)
            for conf_file in conf_file_array.split(';'):
                # translate user folder if it contains "~"
                file_path = os.path.expanduser(conf_file)
                # if the path is relative, translate it to absolute path
                if not os.path.isabs(file_path):
                    temp.append(os.path.abspath(os.path.join(os.getcwd(), file_path)))
                else:
                    temp.append(file_path)
            final_cmake_opts.append(item.split('=')[0] + '=' + ';'.join(temp))
        return final_cmake_opts
